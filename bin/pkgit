#!/bin/bash
set -e

doHelp() {
	cat <<-EOF
	pkgit: a git-based (personal) package manager

	# The Short

	To a first approximation pkgit is "just" a wrapper for (a specially
	configured) git with a "build" and "install" command tacked on:
	- cp pkgit \$HOME/bin/pkgit # or \$HOME/.local/bin/pkgit to taste
	- cd path/to/source/tree/for/thing
	- pkgit # build is the default command
	- pkgit install

	# The Long

	pkgit is designed to manage some \$PREFIX, while its primary intention is
	to manage \$HOME/.local, it can in principle work for other things like
	/usr/local.

	\$PREFIX will be managed as a git repository; if it isn't one already,
	pkgit will initialize it.  Packages each get their own sub-repository under
	\$PREFIX/.git/pkg/NAME.

	Each package seb-repo is a a bare git repository with no objects of its own
	(all objects are stored in \$PREFIX/.git/objects).  Build related
	artifacts, mostly temporary in nature, are stored under the package
	sub-repo.

	Builds are done under \$PREFIX/.git/pkg/NAME/{build,install}-VERSION:
	- build-VERSION SHOULD serve as an out-of-tree build directory
	- install-VERSION serves as the working tree
	- the contents of the install-VERSION working tree is then comitted to a
	  branch in the package's repository, and a NAME-VERSION tag is created
	  in the \$PREFIX repository

	The first time a package is built, the user is dropped into an interactive
	shell to perform the build.  After the user exits that shell, their history
	is recorded as a build script for next time.  The contents of the
	install-VERSION directory are committed, along with the build script, into
	a branch in the package sub-repo.  Users may optionally provide an initial
	build script to avoid the interactive process.

	Subsequent builds are then primed by using the build script recorded in the
	last commit.  Whenever a build script is used (either recovered from prior
	commit, or given by the user to \`pkgit build ...\`), the user is presented
	with it in their \$EDITOR.  The user has a chance to instrument the build
	script with interactive shell "breakpoints".  Just like the initial
	interactive shell, any history within these breakpoints is recorded for
	inclusion in the resulting build script.

	Installs are done by merging a built tag into \$PREFIX; however the user
	can just as easily \`cd \$PREFIX\` git-around themselves; pkgit currently
	add most of its value during the above build phase, and generally
	managing each package's sub-repository. NOTE/TODO: merging already
	large-ish branches together into an even bigger working tree may quickly
	known scaling limit in git; because of this, and also to ease things like
	up/down-grades the user and/or pkgit itself should explore using \`git
	submodule\` rather than the current tree-grafting approach.

	## Variants

	TODO explain this in longer form, basically it's multiple branches within
	the sub-repo, keyed off some extracted version component from the source
	tree; e.g. to separate python2 and python3.

	# Inspiration / Motivation:

	- inspired by [A Crude Personal Package Manager](http://nullprogram.com/blog/2018/03/27/)
	- pkgit set(s) out to be "A Less Crude Personal Package Manager"
	- in other words, this grew out of my initial "tar(balls)?!? who uses
	  tar(balls) in 2018? Software comes through git, and git can manage the
	  installed artifacts better to boot!" reaction to reading said blog post.
	EOF
}

die() {
	echo "$@" >&2
	exit 1
}

inspectPackage() {
	PREFIX=$PKGROOT
	SRCDIR=$1
	PKGNAME=$(basename "$SRCDIR")
	PKGDIR=$PKGREPO/pkg/$PKGNAME

	PKGVARIANT=
	PKGREF=$(pkgit symbolic-ref HEAD)
	if [ -f "$PKGDIR/variant" ]; then
		PKGVARIANT=$(bash "$PKGDIR/variant")
		PREFIX+=/$PKGVARIANT
		if [ "$PKGREF" != "refs/heads/$PKGVARIANT" ]; then
			PKGREF="refs/heads/$PKGVARIANT"
			pkgit symbolic-ref HEAD "$PKGREF"
		fi
	fi

	PKGHEAD=$(basename "$(git --git-dir="$SRCDIR/.git" symbolic-ref HEAD 2>/dev/null)") || true
	PKGREMOTE=$(git --git-dir="$SRCDIR/.git" config "branch.${PKGHEAD:-master}.remote" 2>/dev/null) || true
	PKGURL=$(git --git-dir="$SRCDIR/.git" config "remote.${PKGREMOTE:-origin}.url")
	PKGREV=$(git --git-dir="$SRCDIR/.git" rev-parse HEAD)
	PKGDESC=$(
		git --git-dir="$SRCDIR/.git" describe "$PKGREV" 2>/dev/null ||
		git --git-dir="$SRCDIR/.git" describe --tags "$PKGREV" 2>/dev/null ||
		git --git-dir="$SRCDIR/.git" describe --all --always "$PKGREV"
	)

	PKGVERSION=${PKGDESC##*/}
	BUILDDIR=$PKGDIR/build-$PKGVERSION
	DESTDIR=$PKGDIR/install-$PKGVERSION
}

pkgit() {
	[ -d "$PKGDIR" ] || GIT_OBJECT_DIRECTORY="$PKGREPO/objects" setupSubRepo
	GIT_OBJECT_DIRECTORY="$PKGREPO/objects" git --git-dir="$PKGDIR" "$@"
}

setupSubRepo() {
	git init --bare "$PKGDIR"
	rm -rf "$PKGDIR"/{hooks/*,objects}
	git --git-dir="$PKGDIR" symbolic-ref HEAD "refs/heads/$PKGNAME"
}

priorBuild() {
	ref=${1:-$PKGREF}
	echo "## prior build script from $ref"
	echo "##"
	pkgit show "$ref" -s --pretty='commit %h%d%ntree %t%nAuthored by %an <%ae> at %ai%nCommitted by %cn <%ce> at %ci%nSubject: %B' \
	| awk 'BEGIN { prefix="## " }; { print prefix $0; if (match($0, "Script:") == 1) {prefix=""} }'
	echo ""
	echo "## NOTE: you may add any number \`shell\` lines to drop into a shell within"
	echo "##       the build environment; any commands executed within it are captured"
	echo "##       for the final build script."
}

withBuild() {
	if [ -n "$PKGIT_DRYRUN" ]; then
		if [ "$1" == "bash" ] && [ $# -eq 2 ]; then
			echo cd "$BUILDDIR" '&& {'
			sed -e 's/^/  /' "$2"
			echo '}'
		else
			echo cd "$BUILDDIR" '&&' "$@"
		fi
		return
	fi
	export BUILDDIR DESTDIR PKGNAME PKGREPO PKGVERSION PREFIX SRCDIR
	mkdir -p "$BUILDDIR"
	cd "$BUILDDIR"
	"$@"
}

commitMess() {
	cat <<EOM
Built $PKGVERSION

Source: $SRCDIR
Upstream: $PKGURL
Revision: $PKGREV

Script:
$(grep -v '^##' "$PKGDIR/build.bash")

# Diff Stat:
$(pkgit diff --cached --stat | sed -e 's/^/# /')
EOM
}

historyBuild() {
	cat <<EOM
# Session shell history:
# TODO: curate this, as it will be used as a rebuild script later!
$(if [ -f "$PKGDIR/history.prior" ]; then
	diff "$PKGDIR/history"{.prior,} | grep '^> ' | cut -c 3-
else
	cat -u "$PKGDIR/history"
fi)
EOM
}

doBuild() {
	if [ -n "$PKGIT_DRYRUN" ]; then
		echo "Dry Run Build Variables:"
		dumpVars
	fi

	prior=$1

	[ -d "$PKGDIR" ] || mkdir -p "$PKGDIR"

	if [ -z "$prior" ] && pkgit rev-parse --verify -q "$PKGREF" >/dev/null; then
		priorBuild "$PKGREF" >"$PKGDIR/prior_build.bash"
		prior="$PKGDIR/prior_build.bash"
	fi

	steps=()

	if [ -n "$prior" ]; then
		cp "$prior" "$PKGDIR/build.bash"
		"$EDITOR" "$PKGDIR/build.bash"

		pushd "$PKGDIR"
		rm -f build.*.bash
		awk -f - build.bash <<- EOA
			BEGIN {n=0; of="build.0.bash"} {
				if (match(\$0, "shell") == 1) {of=sprintf("build.%d.bash", ++n); print "" > of}
				else if (match(\$0, "##") != 1) {print > of} }
			EOA
		popd

		i=0
		while [ -f "$PKGDIR/build.$i.bash" ]; do
			steps+=("$PKGDIR/build.$i.bash")
			i=$(( i + 1 ))
		done
	fi

	if [ -f "$PKGDIR/history" ]; then
		cp "$PKGDIR/history"{,.prior}
	fi

	i=0
	for step in "${steps[@]}"; do
		if [ $i -gt 0 ]; then
			doInteract
		fi
		cat "$step" >> "$PKGDIR/history"
		withBuild bash "$step" 2>&1 | tee "$PKGDIR/build.log"
		i=$(( i + 1 ))
	done
	if [ $i -eq 0 ]; then
		doFirstInteract
	fi

	tag=$PKGNAME-$PKGVERSION
	if [ -n "$PKGIT_DRYRUN" ]; then
		echo "# would add, commit, and tag $tag"
	else
		historyBuild >"$PKGDIR/build.bash"
		tree="$DESTDIR/$PKGROOT"
		cd "$tree"
		GIT_WORK_TREE="$tree" pkgit add .
		commitMess | GIT_WORK_TREE="$tree" pkgit commit -e -F -
		git --git-dir="$PKGREPO" tag -f "$tag" "$(pkgit rev-parse "$PKGREF")"
	fi
}

doFirstInteract() {
	if [ -n "$PKGIT_DRYRUN" ]; then
		echo "# would drop into initial build shell"
		return
	fi
	cat <<-EOF
	Dropping into build shell, salient variables:
	$(dumpVars)

	If the project uses standard autotools, a good start:

	    \$SRCDIR/configure
	    make
	    make install

	If the project uses cmake, try:

	    cmake \$SRCDIR
	    make

	Finally, try to do an "out-of-tree" build, but if you want/need the source:

	    git --git-dir="\$SRCDIR/.git" archive HEAD | tar -x
	EOF
	HISTFILE="$PKGDIR/history" withBuild bash
}

doInteract() {
	if [ -n "$PKGIT_DRYRUN" ]; then
		echo "# would drop into build shell"
		return
	fi
	cat <<-EOF
	Dropping into build shell, salient variables:
	$(dumpVars)

	NOTE: any prior build commands are available in history
	EOF
	HISTFILE="$PKGDIR/history" withBuild bash
}

dumpVars() {
	{
		echo "  VAR=description=value"
		echo "  SRCDIR=Package Source Directory=$SRCDIR"
		echo "  PKGNAME=Package Name=$PKGNAME"
		echo "  PKGVERSION=Package Version=$PKGVERSION"
		echo "  BUILDDIR=Build Scratch Directory=$BUILDDIR"
		echo "  PREFIX=Target Installation Directory=$PREFIX"
		echo "  DESTDIR=Install Destination Directory=$DESTDIR"
	} | column -ts=
}

PKGROOT=$(dirname "$0")
if [[ $PKGROOT = */bin ]]; then
	PKGROOT=${PKGROOT%/bin}
fi
if [ "$PKGROOT" = "$HOME" ]; then
	PKGROOT=$HOME/.local
fi

PKGREPO=$PKGROOT/.git
if ! [ -d "$PKGREPO" ]; then
	pushd "$PKGREPO"
	git init
	rm -f .git/hooks/*.hook
	git commit --allow-empty -m 'Initial Commit Left Intentionally Empty'
	echo "Initialized an empty git repository in $PKGROOT; consider addressing any"
	echo "prior content (commit it, or commit some gitignores for it)." popd
	popd
fi

case "$1" in
help)
	doHelp
	exit 0
	;;

install)
	shift
	if [ $# -eq 0 ]; then
		inspectPackage "$(pwd)"
	else
		die "UNIMPLEMENTED install package by name; only works from within package source tree for now"
	fi
	ref=$(pkgit rev-list "$PKGREF" \
		| git --git-dir="$PKGREPO" name-rev --tags --name-only --stdin \
		| grep -v undefined | head -n1)
	cd "$PKGROOT"
	git --git-dir="$PKGREPO" merge --allow-unrelated-histories --no-edit "$ref"
	echo
	git --git-dir="$PKGREPO" show -s --pretty=oneline --no-decorate
	exit 0
	;;

repogit)
	shift
	cd "$PKGROOT"
	git --git-dir="$PKGREPO" "$@"
	exit 0
	;;
esac

inspectPackage "$(pwd)"

case "$1" in
build-script)
	priorBuild "$2"
	;;

build)
	shift
	doBuild "$@"
	;;

truncate)
	tree=$(pkgit rev-parse "$PKGREF":)
	commit=$(pkgit show -s --pretty=%B "$PKGREF" | pkgit commit-tree "$tree" -F -)
	tag=$PKGNAME-$PKGVERSION
	pkgit update-ref "$PKGREF" "$commit" -m "pkgit truncate"
	git --git-dir="$PKGREPO" tag -f "$tag" "$commit"
	;;

variant)
	shift
	if [ $# -gt 0 ]; then
		echo "$@" >"$PKGDIR/variant"
		PKGVARIANT=$(bash "$PKGDIR/variant")
	fi
	if ! [ -f "$PKGDIR/variant" ]; then
		die "No package variant script configured; run \`pkgit variant ...\` to set one."
	fi
	echo "variant command: \`$(cat "$PKGDIR/variant")\`"
	echo "variant: $PKGVARIANT"
	;;

rm)
	rm -rf "$PKGDIR"
	;;

clean)
	rm -rf "$BUILDDIR" "$DESTDIR"
	;;

*)
	if [ $# -gt 0 ]; then
		pkgit "$@"
	else
		doBuild
	fi
	;;
esac
